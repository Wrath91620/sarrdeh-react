{"ast":null,"code":"const EPSILON = 0.000001;\n\n/**\r\n * Copy the values from one vec2 to another\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the source vector\r\n * @returns {vec2} out\r\n */\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  return out;\n}\n\n/**\r\n * Set the components of a vec2 to the given values\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @returns {vec2} out\r\n */\nexport function set(out, x, y) {\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n\n/**\r\n * Adds two vec2's\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {vec2} out\r\n */\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  return out;\n}\n\n/**\r\n * Subtracts vector b from vector a\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {vec2} out\r\n */\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  return out;\n}\n\n/**\r\n * Multiplies two vec2's\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {vec2} out\r\n */\nexport function multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  return out;\n}\n\n/**\r\n * Divides two vec2's\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {vec2} out\r\n */\nexport function divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  return out;\n}\n\n/**\r\n * Scales a vec2 by a scalar number\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the vector to scale\r\n * @param {Number} b amount to scale the vector by\r\n * @returns {vec2} out\r\n */\nexport function scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  return out;\n}\n\n/**\r\n * Calculates the euclidian distance between two vec2's\r\n *\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {Number} distance between a and b\r\n */\nexport function distance(a, b) {\n  var x = b[0] - a[0],\n    y = b[1] - a[1];\n  return Math.sqrt(x * x + y * y);\n}\n\n/**\r\n * Calculates the squared euclidian distance between two vec2's\r\n *\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {Number} squared distance between a and b\r\n */\nexport function squaredDistance(a, b) {\n  var x = b[0] - a[0],\n    y = b[1] - a[1];\n  return x * x + y * y;\n}\n\n/**\r\n * Calculates the length of a vec2\r\n *\r\n * @param {vec2} a vector to calculate length of\r\n * @returns {Number} length of a\r\n */\nexport function length(a) {\n  var x = a[0],\n    y = a[1];\n  return Math.sqrt(x * x + y * y);\n}\n\n/**\r\n * Calculates the squared length of a vec2\r\n *\r\n * @param {vec2} a vector to calculate squared length of\r\n * @returns {Number} squared length of a\r\n */\nexport function squaredLength(a) {\n  var x = a[0],\n    y = a[1];\n  return x * x + y * y;\n}\n\n/**\r\n * Negates the components of a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a vector to negate\r\n * @returns {vec2} out\r\n */\nexport function negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  return out;\n}\n\n/**\r\n * Returns the inverse of the components of a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a vector to invert\r\n * @returns {vec2} out\r\n */\nexport function inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  return out;\n}\n\n/**\r\n * Normalize a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a vector to normalize\r\n * @returns {vec2} out\r\n */\nexport function normalize(out, a) {\n  var x = a[0],\n    y = a[1];\n  var len = x * x + y * y;\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  return out;\n}\n\n/**\r\n * Calculates the dot product of two vec2's\r\n *\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {Number} dot product of a and b\r\n */\nexport function dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1];\n}\n\n/**\r\n * Computes the cross product of two vec2's\r\n * Note that the cross product returns a scalar\r\n *\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {Number} cross product of a and b\r\n */\nexport function cross(a, b) {\n  return a[0] * b[1] - a[1] * b[0];\n}\n\n/**\r\n * Performs a linear interpolation between two vec2's\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @param {Number} t interpolation amount between the two inputs\r\n * @returns {vec2} out\r\n */\nexport function lerp(out, a, b, t) {\n  var ax = a[0],\n    ay = a[1];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  return out;\n}\n\n/**\r\n * Performs a frame rate independant, linear interpolation between two vec2's\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @param {Number} decay decay constant for interpolation. useful range between 1 and 25, from slow to fast.\r\n * @param {Number} dt delta time\r\n * @returns {vec2} out\r\n */\nexport function smoothLerp(out, a, b, decay, dt) {\n  const exp = Math.exp(-decay * dt);\n  let ax = a[0];\n  let ay = a[1];\n  out[0] = b[0] + (ax - b[0]) * exp;\n  out[1] = b[1] + (ay - b[1]) * exp;\n  return out;\n}\n\n/**\r\n * Transforms the vec2 with a mat2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the vector to transform\r\n * @param {mat2} m matrix to transform with\r\n * @returns {vec2} out\r\n */\nexport function transformMat2(out, a, m) {\n  var x = a[0],\n    y = a[1];\n  out[0] = m[0] * x + m[2] * y;\n  out[1] = m[1] * x + m[3] * y;\n  return out;\n}\n\n/**\r\n * Transforms the vec2 with a mat2d\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the vector to transform\r\n * @param {mat2d} m matrix to transform with\r\n * @returns {vec2} out\r\n */\nexport function transformMat2d(out, a, m) {\n  var x = a[0],\n    y = a[1];\n  out[0] = m[0] * x + m[2] * y + m[4];\n  out[1] = m[1] * x + m[3] * y + m[5];\n  return out;\n}\n\n/**\r\n * Transforms the vec2 with a mat3\r\n * 3rd vector component is implicitly '1'\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the vector to transform\r\n * @param {mat3} m matrix to transform with\r\n * @returns {vec2} out\r\n */\nexport function transformMat3(out, a, m) {\n  var x = a[0],\n    y = a[1];\n  out[0] = m[0] * x + m[3] * y + m[6];\n  out[1] = m[1] * x + m[4] * y + m[7];\n  return out;\n}\n\n/**\r\n * Transforms the vec2 with a mat4\r\n * 3rd vector component is implicitly '0'\r\n * 4th vector component is implicitly '1'\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the vector to transform\r\n * @param {mat4} m matrix to transform with\r\n * @returns {vec2} out\r\n */\nexport function transformMat4(out, a, m) {\n  let x = a[0];\n  let y = a[1];\n  out[0] = m[0] * x + m[4] * y + m[12];\n  out[1] = m[1] * x + m[5] * y + m[13];\n  return out;\n}\n\n/**\r\n * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)\r\n *\r\n * @param {vec2} a The first vector.\r\n * @param {vec2} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1];\n}","map":{"version":3,"names":["EPSILON","copy","out","a","set","x","y","add","b","subtract","multiply","divide","scale","distance","Math","sqrt","squaredDistance","length","squaredLength","negate","inverse","normalize","len","dot","cross","lerp","t","ax","ay","smoothLerp","decay","dt","exp","transformMat2","m","transformMat2d","transformMat3","transformMat4","exactEquals"],"sources":["C:/Users/Sarrdeh Tech/Desktop/Sarrdeh-React/sarrdeh-react/node_modules/ogl/src/math/functions/Vec2Func.js"],"sourcesContent":["const EPSILON = 0.000001;\r\n\r\n/**\r\n * Copy the values from one vec2 to another\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the source vector\r\n * @returns {vec2} out\r\n */\r\nexport function copy(out, a) {\r\n    out[0] = a[0];\r\n    out[1] = a[1];\r\n    return out;\r\n}\r\n\r\n/**\r\n * Set the components of a vec2 to the given values\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @returns {vec2} out\r\n */\r\nexport function set(out, x, y) {\r\n    out[0] = x;\r\n    out[1] = y;\r\n    return out;\r\n}\r\n\r\n/**\r\n * Adds two vec2's\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {vec2} out\r\n */\r\nexport function add(out, a, b) {\r\n    out[0] = a[0] + b[0];\r\n    out[1] = a[1] + b[1];\r\n    return out;\r\n}\r\n\r\n/**\r\n * Subtracts vector b from vector a\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {vec2} out\r\n */\r\nexport function subtract(out, a, b) {\r\n    out[0] = a[0] - b[0];\r\n    out[1] = a[1] - b[1];\r\n    return out;\r\n}\r\n\r\n/**\r\n * Multiplies two vec2's\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {vec2} out\r\n */\r\nexport function multiply(out, a, b) {\r\n    out[0] = a[0] * b[0];\r\n    out[1] = a[1] * b[1];\r\n    return out;\r\n}\r\n\r\n/**\r\n * Divides two vec2's\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {vec2} out\r\n */\r\nexport function divide(out, a, b) {\r\n    out[0] = a[0] / b[0];\r\n    out[1] = a[1] / b[1];\r\n    return out;\r\n}\r\n\r\n/**\r\n * Scales a vec2 by a scalar number\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the vector to scale\r\n * @param {Number} b amount to scale the vector by\r\n * @returns {vec2} out\r\n */\r\nexport function scale(out, a, b) {\r\n    out[0] = a[0] * b;\r\n    out[1] = a[1] * b;\r\n    return out;\r\n}\r\n\r\n/**\r\n * Calculates the euclidian distance between two vec2's\r\n *\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {Number} distance between a and b\r\n */\r\nexport function distance(a, b) {\r\n    var x = b[0] - a[0],\r\n        y = b[1] - a[1];\r\n    return Math.sqrt(x * x + y * y);\r\n}\r\n\r\n/**\r\n * Calculates the squared euclidian distance between two vec2's\r\n *\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {Number} squared distance between a and b\r\n */\r\nexport function squaredDistance(a, b) {\r\n    var x = b[0] - a[0],\r\n        y = b[1] - a[1];\r\n    return x * x + y * y;\r\n}\r\n\r\n/**\r\n * Calculates the length of a vec2\r\n *\r\n * @param {vec2} a vector to calculate length of\r\n * @returns {Number} length of a\r\n */\r\nexport function length(a) {\r\n    var x = a[0],\r\n        y = a[1];\r\n    return Math.sqrt(x * x + y * y);\r\n}\r\n\r\n/**\r\n * Calculates the squared length of a vec2\r\n *\r\n * @param {vec2} a vector to calculate squared length of\r\n * @returns {Number} squared length of a\r\n */\r\nexport function squaredLength(a) {\r\n    var x = a[0],\r\n        y = a[1];\r\n    return x * x + y * y;\r\n}\r\n\r\n/**\r\n * Negates the components of a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a vector to negate\r\n * @returns {vec2} out\r\n */\r\nexport function negate(out, a) {\r\n    out[0] = -a[0];\r\n    out[1] = -a[1];\r\n    return out;\r\n}\r\n\r\n/**\r\n * Returns the inverse of the components of a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a vector to invert\r\n * @returns {vec2} out\r\n */\r\nexport function inverse(out, a) {\r\n    out[0] = 1.0 / a[0];\r\n    out[1] = 1.0 / a[1];\r\n    return out;\r\n}\r\n\r\n/**\r\n * Normalize a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a vector to normalize\r\n * @returns {vec2} out\r\n */\r\nexport function normalize(out, a) {\r\n    var x = a[0],\r\n        y = a[1];\r\n    var len = x * x + y * y;\r\n    if (len > 0) {\r\n        //TODO: evaluate use of glm_invsqrt here?\r\n        len = 1 / Math.sqrt(len);\r\n    }\r\n    out[0] = a[0] * len;\r\n    out[1] = a[1] * len;\r\n    return out;\r\n}\r\n\r\n/**\r\n * Calculates the dot product of two vec2's\r\n *\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {Number} dot product of a and b\r\n */\r\nexport function dot(a, b) {\r\n    return a[0] * b[0] + a[1] * b[1];\r\n}\r\n\r\n/**\r\n * Computes the cross product of two vec2's\r\n * Note that the cross product returns a scalar\r\n *\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {Number} cross product of a and b\r\n */\r\nexport function cross(a, b) {\r\n    return a[0] * b[1] - a[1] * b[0];\r\n}\r\n\r\n/**\r\n * Performs a linear interpolation between two vec2's\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @param {Number} t interpolation amount between the two inputs\r\n * @returns {vec2} out\r\n */\r\nexport function lerp(out, a, b, t) {\r\n    var ax = a[0],\r\n        ay = a[1];\r\n    out[0] = ax + t * (b[0] - ax);\r\n    out[1] = ay + t * (b[1] - ay);\r\n    return out;\r\n}\r\n\r\n/**\r\n * Performs a frame rate independant, linear interpolation between two vec2's\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @param {Number} decay decay constant for interpolation. useful range between 1 and 25, from slow to fast.\r\n * @param {Number} dt delta time\r\n * @returns {vec2} out\r\n */\r\nexport function smoothLerp(out, a, b, decay, dt) {\r\n    const exp = Math.exp(-decay * dt);\r\n    let ax = a[0];\r\n    let ay = a[1];\r\n\r\n    out[0] = b[0] + (ax - b[0]) * exp;\r\n    out[1] = b[1] + (ay - b[1]) * exp;\r\n    return out;\r\n}\r\n\r\n/**\r\n * Transforms the vec2 with a mat2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the vector to transform\r\n * @param {mat2} m matrix to transform with\r\n * @returns {vec2} out\r\n */\r\nexport function transformMat2(out, a, m) {\r\n    var x = a[0],\r\n        y = a[1];\r\n    out[0] = m[0] * x + m[2] * y;\r\n    out[1] = m[1] * x + m[3] * y;\r\n    return out;\r\n}\r\n\r\n/**\r\n * Transforms the vec2 with a mat2d\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the vector to transform\r\n * @param {mat2d} m matrix to transform with\r\n * @returns {vec2} out\r\n */\r\nexport function transformMat2d(out, a, m) {\r\n    var x = a[0],\r\n        y = a[1];\r\n    out[0] = m[0] * x + m[2] * y + m[4];\r\n    out[1] = m[1] * x + m[3] * y + m[5];\r\n    return out;\r\n}\r\n\r\n/**\r\n * Transforms the vec2 with a mat3\r\n * 3rd vector component is implicitly '1'\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the vector to transform\r\n * @param {mat3} m matrix to transform with\r\n * @returns {vec2} out\r\n */\r\nexport function transformMat3(out, a, m) {\r\n    var x = a[0],\r\n        y = a[1];\r\n    out[0] = m[0] * x + m[3] * y + m[6];\r\n    out[1] = m[1] * x + m[4] * y + m[7];\r\n    return out;\r\n}\r\n\r\n/**\r\n * Transforms the vec2 with a mat4\r\n * 3rd vector component is implicitly '0'\r\n * 4th vector component is implicitly '1'\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the vector to transform\r\n * @param {mat4} m matrix to transform with\r\n * @returns {vec2} out\r\n */\r\nexport function transformMat4(out, a, m) {\r\n    let x = a[0];\r\n    let y = a[1];\r\n    out[0] = m[0] * x + m[4] * y + m[12];\r\n    out[1] = m[1] * x + m[5] * y + m[13];\r\n    return out;\r\n}\r\n\r\n/**\r\n * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)\r\n *\r\n * @param {vec2} a The first vector.\r\n * @param {vec2} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\r\nexport function exactEquals(a, b) {\r\n    return a[0] === b[0] && a[1] === b[1];\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}